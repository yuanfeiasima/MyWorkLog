1. acid

2. mvcc 间隙锁

3. 普通索引  
   1. [http://www.cnblogs.com/farmer-cabbage/p/5793589.html](http://www.cnblogs.com/farmer-cabbage/p/5793589.html)

4. 聚簇索引 非聚簇索引  
   1. [http://www.tuicool.com/articles/VramY3Y](#)

   1. [http://note.youdao.com/noteshare?id=7caa792d34b774dca05e9ac29fced170](#)

5. b树 b-树 b+树

   * b-树，节点有数据，b+树子节点才有数据
   * b+树叶子节点有指针指向下一叶子节点，提高查找效率，顺序读取和排序
   * b+树的内节点不存储数据信息，因此能够生成的每一层的内节点就会多，对内存的开销小

6. 聚簇索引 --顺序结构与数据存储屋里结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条

   * * innoDB中设置与业务无关的自增id，然后设为主键，

     * 因为innoDB是聚簇索引，插入之后b+树不用在平衡，如果该值大小不定，会引起再平衡，影响插入效率

     * 聚簇索引存放的是数据信息，非聚簇索引存放的是指向数据的指针

     * 聚簇索引需要对数据的物理存放进行排序，所以一张表只有一个聚簇索引

     * innoDB引擎下的表都会建立聚簇索引，如果有主键，就用主键，如果没有主键，就找一个非空的唯一索引，如果没有，会自动创建一个隐藏的主键。

     * innodb的主键默认是聚簇索引吗？对， 也可以先设其他值为聚簇索引，再设置主键，主键就不是聚簇索引了吧 对

     * innodb中，聚簇索引是mysql自己来决定的。选择的顺序是：（1）定义了主键，就选择主键；（2）没有主键，选择第一个非空的唯一索引；（3）两者都没有，innodb自己生成一个占6byte的自增长列。然后以它作为聚簇索引列

     * innoDB下的非聚簇索引的叶子节点存放的都是主键id，使用 非主键的索引都会再走一遍主键索引

     * 聚簇索引是基础，表示数据和b+树之间的关系，聚簇索引是对存储在磁盘上的数据重新组织以按照一个或多个列的值排序的算法

7. innoDB 锁原理

   * 只有通过索引条件检索数据，innoDB才使用行级锁，否则InnoDB将使用表锁，在实际开发中应当注意；如果索引建立的不合适，优化器有可能使用表锁
   * 行锁是加在记录上的锁，InnoDB中的记录是以B+树索引的方式组织在一起的，InnoDB的行锁实际是 index record lock，即对B+索引叶子节点的锁。索引可能有多个，因此操作一行数据时，有可能会加多个行锁在不同的B+树上。

   * 这个是属于大偏移量分页 select \* from t where id &gt; 10000 limit 10

   * 最好避免随机的聚簇索引，特别对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID作为聚簇索引会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。通过测试，向UUID主键插入行不仅花费的时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长，另一方面毫无疑问是由于页分裂和碎片导致的。

   * record lock gap lock next-key-lock（nextkeylock对查询范围进行加锁，在另一个事务执行插入操作时是不被执行的，所以避免了幻读）[http://www.jianshu.com/p/bf862c37c4c9](http://www.jianshu.com/p/bf862c37c4c9)

8. in or 走索引的问题

   * in会走索引，但是如果传入的值不存在是不是不走索引？？
   * or不会走？

9. 最左原则

10. 死锁

11. 索引建立技巧

12. for update 是否打开事务



